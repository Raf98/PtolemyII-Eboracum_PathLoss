/* Generated by Ptolemy II (http://ptolemy.eecs.berkeley.edu)
Copyright (c) 2005-2010 The Regents of the University of California.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.
IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
*/
#ifndef PT_NO_MATH_H
#include <math.h>
#endif
#ifndef PT_NO_STDIO_H
#include <stdio.h>
#endif
#ifndef PT_NO_STDLIB_H
#include <stdlib.h>
#endif
#ifndef PT_NO_STDARG_H
#include <stdarg.h>
#endif
#ifndef PT_NO_STRING_H
#include <string.h>
#endif
/* Generate type resolution code for .Ramp */
// Constants.
#define MISSING 0
typedef unsigned char boolean;
typedef char* string;
/* Infinity is a valid Ptolemy identifier. */
#define Infinity HUGE_VAL
#ifdef linux
/* Linux tends to have NAN. */
#define NaN (__builtin_nanf (""))
#else /*linux*/
#define NaN nanf(0)
#endif /*linux*/
#define false 0
#define true 1
#define TYPE_Token -1
#define TYPE_Double 0
#define TYPE_Boolean 1
#define TYPE_IntArray 2
#define TYPE_Int 3
#define FUNC_convert 0
#define FUNC_isCloseTo 1
#define FUNC_delete 2
typedef struct token Token;
typedef double DoubleToken;
typedef boolean BooleanToken;
Token IntArray_new(int size, int given, ...);
struct intarray {
    int size;                                   // size of the array.
    int* elements;                            // array of Token elements.
    char elementType;                                 // type of the elements.
};
typedef struct intarray* IntArrayToken;
typedef int IntToken;
// Token structure containing the specified types.
struct token {         // Base type for tokens.
    char type;         // TYPE field has to be the first field.
    union typeMembers {
        // type member declarations [i.e. Type1Token Type1;]
        DoubleToken Double;
        BooleanToken Boolean;
        IntArrayToken IntArray;
        IntToken Int;
    } payload;
};
Token emptyToken; /* Used by *_delete() and others. */
Token Double_new(double d);
Token Boolean_new(boolean b);
// IntArray_get: get an element of an array.
#define IntArray_length(array) ((array).payload.IntArray->size)
int IntArray_get(Token array, int i) {
    // Token result;
    // result.type = array.payload.IntArray->elementType;
    // result.payload.Int = ((int *) array.payload.IntArray->elements)[i];
    // return result;
    return ((int *) array.payload.IntArray->elements)[i];
}
// IntArray_set: set an element of an array.
void IntArray_set(Token array, int i, int element) {
    ((int *) array.payload.IntArray->elements)[i] = element;
}
// IntArray_resize: Change the size of an array,
// preserving those elements that fit.
void IntArray_resize(Token array, int size) {
    if (array.payload.IntArray->size == 0) {
        array.payload.IntArray->elements = (int *) malloc(size * sizeof(int));
    } else {
        array.payload.IntArray->elements = (int*) realloc(
        array.payload.IntArray->elements, size * sizeof(int));
    }
    array.payload.IntArray->size = size;
}
// IntArray_insert: Append the specified element to the end of an array.
void IntArray_insert(Token array, int token) {
    // FIXME: call this append(), not insert().
    int oldSize = array.payload.IntArray->size;
    IntArray_resize(array, oldSize + 1 );
    ((int *) array.payload.IntArray->elements)[oldSize] = token;
}
Token Int_new(int i);
#define StringtoInt atoi
#define StringtoDouble atof
#define StringtoLong atol
#define DoubletoInt (int)
#define InttoDouble (double)
#define InttoLong (long)
char* InttoString (int i) {
    char* string = (char*) malloc(sizeof(char) * 12);
    sprintf((char*) string, "%d", i);
    return string;
}
char* LongtoString (long long l) {
    char* string = (char*) malloc(sizeof(char) * 22);
    sprintf(string, "%lld", l);
    return string;
}
char* DoubletoString (double d) {
    int index;
    char* string = (char*) malloc(sizeof(char) * 20);
    sprintf(string, "%.14g", d);
    // Make sure that there is a decimal point.
    if (strrchr(string, '.') == NULL) {
        index = strlen(string);
        if (index == 20) {
            string = (char*) realloc(string, sizeof(char) * 22);
        }
        string[index] = '.';
        string[index + 1] = '0';
        string[index + 2] = '\0';
    }
    return string;
}
char* BooleantoString (boolean b) {
    char *results;
    if (b) {
        // AVR does not have strdup
        results = (char*) malloc(sizeof(char) * 5);
        strcpy(results, "true");
    } else {
        results = (char*) malloc(sizeof(char) * 6);
        strcpy(results, "false");
    }
    return results;
}
char* UnsignedBytetoString (unsigned char b) {
    char* string = (char*) malloc(sizeof(char) * 3);
    sprintf(string, "%d", (int) b);
    return string;
}
// functionHeader:
Token Double_convert (Token thisToken, ...);
// functionHeader:
Token Double_isCloseTo (Token thisToken, ...);
// functionHeader:
Token Boolean_convert (Token thisToken, ...);
Token Boolean_equals (Token thisToken, ...);
// functionHeader:
Token Boolean_equals (Token thisToken, ...);
// functionHeader:
Token IntArray_convert (Token thisToken, ...);
// functionHeader:
Token IntArray_isCloseTo (Token thisToken, ...);
// functionHeader:
Token IntArray_delete (Token thisToken, ...);
// functionHeader:
Token Int_convert (Token thisToken, ...);
// functionHeader:
Token Int_isCloseTo (Token thisToken, ...);
/* We share one method between all scalar types so as to reduce code size. */
Token scalarDelete(Token token, ...) {
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
#define NUM_TYPE 4
#define NUM_FUNC 3
Token (*functionTable[NUM_TYPE][NUM_FUNC])(Token, ...)= {
{Double_convert, Double_isCloseTo, scalarDelete},
{Boolean_convert, Boolean_equals, scalarDelete},
{IntArray_convert, IntArray_isCloseTo, IntArray_delete},
{Int_convert, Int_isCloseTo, scalarDelete}
};
int convert_Int_Int(int a) {
    return a;
}
int multiply_Int_Int(int a1, int a2) {
    return a1 * a2;
}
int subtract_Int_Int(int a1, int a2) {
    return a1 - a2;
}
int add_Int_Int(int a1, int a2) {
    return a1 + a2;
}
// IntArray_new: Create a new array with the specified elements.
//  The "size" argument specifies the size of the array, and
// the "given" argument specifies the number of provided elements
// (which will typically be <= size).
// The rest of the arguments are the provided elements (there
// should be "given" of them). The given elements
// should be of type Token *.
// If the "given" argument is greater than 0, then the last
// argument is expected to be the type that of the elements.
Token IntArray_new(int size, int given, ...) {
    va_list argp;
    int i;
    Token result;
    result.type = TYPE_IntArray;
    result.payload.IntArray = (IntArrayToken) malloc(sizeof(struct intarray));
    result.payload.IntArray->size = size;
    result.payload.IntArray->elementType = TYPE_Int;
    // Only call calloc if size > 0.  Otherwise Electric Fence reports
    // an error.
    if (size > 0) {
        // Allocate an new array of Tokens.
        result.payload.IntArray->elements =
        (int *) calloc(size, sizeof(int));
        if (given > 0) {
            va_start(argp, given);
            for (i = 0; i < given; i++) {
                result.payload.IntArray->elements[i] = (int) va_arg(argp, int);
            }
            va_end(argp);
        }
    }
    return result;
}
Token Double_convert(Token token, ...) {
    switch (token.type) {
        #ifdef TYPE_String
        case TYPE_String:
        // FIXME: Is this safe?
        token.type = TYPE_Double;
        if (sscanf(token.payload.String, "%lg", &token.payload.Double) != 1) {
            fprintf(stderr, "Double_convert(): failed to convert \"%s\" to a Double\n", token.payload.String);
            exit(-1);
        }
        break;
        #endif
        #ifdef TYPE_Int
        case TYPE_Int:
        token.type = TYPE_Double;
        token.payload.Double = InttoDouble(token.payload.Int);
        break;
        #endif
        // FIXME: not finished
        default:
        fprintf(stderr, "Double_convert(): Conversion from an unsupported type. (%d)\n", token.type);
        exit(-1);
        break;
    }
    token.type = TYPE_Double;
    return token;
}
// make a new integer token from the given value.
Token Boolean_new(boolean b) {
    Token result;
    result.type = TYPE_Boolean;
    result.payload.Boolean = b;
    return result;
}
Token Double_isCloseTo(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    tolerance = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(fabs(thisToken.payload.Double - otherToken.payload.Double) < tolerance.payload.Double);
}
/* Instead of Double_delete(), we call scalarDelete(). */
Token Boolean_convert(Token token, ...) {
    switch (token.type) {
        // FIXME: not finished
        default:
        fprintf(stderr, "Boolean_convert(): Conversion from an unsupported type. (%d)", token.type);
        break;
    }
    token.type = TYPE_Boolean;
    return token;
}
Token Boolean_equals(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(( thisToken.payload.Boolean && otherToken.payload.Boolean ) ||
    ( !thisToken.payload.Boolean && !otherToken.payload.Boolean ));
}
/* Instead of Boolean_delete(), we call scalarDelete(). */
// IntArray_convert: Convert the first argument array
// into the type specified by the second argument.
// @param token The token to be converted.
// @param targetType The type to convert the elements of the given token to.
Token IntArray_convert(Token token, ...) {
    //    int i;
    //    Token result;
    //    Token element;
    //    va_list argp;
    //    char targetType;
    //
    //    va_start(argp, token);
    //    targetType = va_arg(argp, int);
    //
    //    // FIXME: HOW DO WE KNOW WHICH TYPE WE'RE CONVERTING TO?
    //    result = IntArray_new(token.payload.IntArray->size, 0);
    //
    //    for (i = 0; i < token.payload.IntArray->size; i++) {
        //        element = IntArray_get(token, i);
        //        if (targetType != token.payload.IntArray->elementType) {
            //
            //                IntArray_set(result, i, functionTable[(int)targetType][FUNC_convert](element));
            //            // result.payload.IntArray->elements[i] = functionTable[(int)targetType][FUNC_convert](element);
        //        } else {
            //                IntArray_set(result, i, element);
        //        }
    //    }
    //
    //    va_end(argp);
    //    return result;
    return token;
}
// IntArray_isCloseTo: Test an array to see whether it is close in value to another.
Token IntArray_isCloseTo(Token thisToken, ...) {
    int i;
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    otherToken = IntArray_convert(otherToken);
    int value1, value2;
    tolerance = va_arg(argp, Token);
    if (thisToken.payload.IntArray->size != otherToken.payload.IntArray->size) {
        return Boolean_new(false);
    }
    for (i = 0; i < thisToken.payload.IntArray->size; i++) {
        value1 = IntArray_get(thisToken, i);
        value2 = IntArray_get(otherToken, i);
        if (fabs(value1 - value2) > tolerance.payload.Double) {
            return Boolean_new(false);
        }
    }
    va_end(argp);
    return Boolean_new(true);
}
// IntArray_delete: FIXME: What does this do?
Token IntArray_delete(Token token, ...) {
    Token emptyToken;
    //Token element;
    //int i;
    //char elementType;
    // Delete each elements.
    // for (i = 0; i < token.payload.IntArray->size; i++) {
        //     elementType = token.payload.IntArray->elementType;
        //     element = IntArray_get(token, i);
        //     functionTable[(int) elementType][FUNC_delete](element);
    // }
    free((int *) token.payload.IntArray->elements);
    free(token.payload.IntArray);
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
Token Int_convert(Token token, ...) {
    switch (token.type) {
        #ifdef TYPE_Double
        case TYPE_Double:
        token.payload.Int = DoubletoInt(token.payload.Double);
        break;
        #endif
        // FIXME: not finished
        default:
        fprintf(stderr, "Int_convert(): Conversion from an unsupported type. (%d)\n", token.type);
        break;
    }
    token.type = TYPE_Int;
    return token;
}
Token Int_isCloseTo(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    tolerance = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(fabs(thisToken.payload.Int - otherToken.payload.Int) < tolerance.payload.Double);
}
/* Instead of Int_delete(), we call scalarDelete(). */
/* end shared code */
/* Ramp_Scale's input variable declarations. */
static int Ramp_Scale_input;
/* Ramp_AddSubtract's input variable declarations. */
static int Ramp_AddSubtract_plus[1];
static int Ramp_AddSubtract_minus[1];
/* Ramp_Ramp's referenced parameter declarations. */
static int Ramp_Ramp_step_;
/* Ramp_Ramp2's referenced parameter declarations. */
static int Ramp_Ramp2_step_;
/* Ramp_Test's referenced parameter declarations. */
static double Ramp_Test_tolerance_;
static Token Ramp_Test_correctValues_;
/* Ramp_Test's input variable declarations. */
static int Ramp_Test_input[1];
/* Ramp_Test's output variable declarations. */
static boolean Ramp_Test_output;
/* The preinitialization of the director. */
/* preinitialize AddSubtract */
int Ramp_AddSubtract__result;
/* preinitRamp */
static int Ramp_Ramp__state;
/* preinitRamp2 */
static int Ramp_Ramp2__state;
/* preinitTest */
// Initialize to -1 because we ALWAYS increment first.
// This is more convenient for multiport, where we check if \$channel
// number is equal zero (the first channel). If so, then we increment.
int Ramp_Test__numberOfTokensSeen = -1;
int Ramp_Test__inputToken;
Token Ramp_Test__trainedValues;
/* end preinitialize code */
/* before appending fireFunctionCode */
void Ramp_Scale(void) {
    Ramp_Test_input[0] = multiply_Int_Int(Ramp_Scale_input, 1);
}
void Ramp_AddSubtract(void) {
    Ramp_AddSubtract__result = Ramp_AddSubtract_plus[0];
    Ramp_AddSubtract__result = subtract_Int_Int(Ramp_AddSubtract__result, Ramp_AddSubtract_minus[0]);
    Ramp_Scale_input = Ramp_AddSubtract__result;
}
void Ramp_Ramp(void) {
    Ramp_AddSubtract_plus[0] = Ramp_Ramp__state;
    // FIXME: this should be put into the postfireBlock
    // but postfire code generation is not working correctly yet.
    Ramp_Ramp__state = add_Int_Int(Ramp_Ramp__state, Ramp_Ramp_step_);
}
void Ramp_Ramp2(void) {
    Ramp_AddSubtract_minus[0] = Ramp_Ramp2__state;
    // FIXME: this should be put into the postfireBlock
    // but postfire code generation is not working correctly yet.
    Ramp_Ramp2__state = add_Int_Int(Ramp_Ramp2__state, Ramp_Ramp2_step_);
}
void Ramp_Test(void) {
    Ramp_Test__inputToken = Ramp_Test_input[0];
    Ramp_Test__numberOfTokensSeen++;
    /* Ramp_Test_, IntBlock(0) which has only one channel */
    if (Ramp_Test__numberOfTokensSeen < 3
    && fabs(Ramp_Test__inputToken
    - /*CGH77*//*CGH77*/IntArray_get(Ramp_Test_correctValues_ , Ramp_Test__numberOfTokensSeen))
    > Ramp_Test_tolerance_) {
        printf("\nTest Ramp_Test__0 fails in iteration %d.\n Value was: %d. Should have been between: %10.30g and %10.30g\n",
        Ramp_Test__numberOfTokensSeen,
        Ramp_Test__inputToken,
        /*CGH77*//*CGH77*/IntArray_get(Ramp_Test_correctValues_ , Ramp_Test__numberOfTokensSeen) -
        Ramp_Test_tolerance_,
        /*CGH77*//*CGH77*/IntArray_get(Ramp_Test_correctValues_ , Ramp_Test__numberOfTokensSeen) +
        Ramp_Test_tolerance_);
        exit(-1);
    }
}
void Ramp(void) {
    /* The firing of the StaticSchedulingDirector */
    Ramp_Ramp2();
    Ramp_Ramp();
    Ramp_AddSubtract();
    Ramp_Scale();
    Ramp_Test();
}
/* after appending fireFunctionCode */
void initialize(void) {
    /* Ramp's parameter initialization */
    Ramp_Ramp_step_ = 2;
    /* Ramp2's parameter initialization */
    Ramp_Ramp2_step_ = 1;
    /* Test's parameter initialization */
    Ramp_Test_tolerance_ = 1.0E-9;
    Ramp_Test_correctValues_ = IntArray_new(3, 3, 0, 1, 2);
    /* The initialization of the director. */
    /* initRamp */
    Ramp_Ramp__state = convert_Int_Int(0);
    /* initRamp2 */
    Ramp_Ramp2__state = convert_Int_Int(0);
}
void wrapup(void) {
    /* The wrapup of the director. */
    /* wrapupTest */
    if ((Ramp_Test__numberOfTokensSeen + 1) < 3) {
        printf("\nTest produced only %d tokens, yet the correctValues parameter was expecting %d tokens.\n", Ramp_Test__numberOfTokensSeen, 3);
        exit(-2);
    }
}
int main(int argc, char *argv[]) {
    initialize();
    int iteration;
    for (iteration = 0; iteration < 3; iteration ++) {
        /* The firing of the StaticSchedulingDirector */
        Ramp_Ramp2();
        Ramp_Ramp();
        Ramp_AddSubtract();
        Ramp_Scale();
        Ramp_Test();
        /* The postfire of the director. */
        /* postfireTest */
        // FIXME: should we update this here?
        //Ramp_Test__numberOfTokensSeen++;
    }
    wrapup();
    /* closing exit code */
    exit(0);
}
