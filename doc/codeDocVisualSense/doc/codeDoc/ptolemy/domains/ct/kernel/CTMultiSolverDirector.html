<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="pt">
<head>
<!-- Generated by javadoc (15) on Mon Mar 29 02:51:25 BRT 2021 -->
<title>CTMultiSolverDirector</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-03-29">
<meta name="description" content="declaration: package: ptolemy.domains.ct.kernel, class: CTMultiSolverDirector">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">ptolemy.domains.ct.kernel</a></div>
<h1 title="Class CTMultiSolverDirector" class="title">Class CTMultiSolverDirector</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">ptolemy.kernel.util.NamedObj
<div class="inheritance">ptolemy.kernel.util.Attribute
<div class="inheritance">ptolemy.actor.Director
<div class="inheritance">ptolemy.actor.sched.StaticSchedulingDirector
<div class="inheritance"><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">ptolemy.domains.ct.kernel.CTDirector</a>
<div class="inheritance">ptolemy.domains.ct.kernel.CTMultiSolverDirector</div>
</div>
</div>
</div>
</div>
</div>
</div>
<section class="description">
<dl class="notes">
<dt>All Implemented Interfaces:</dt>
<dd><code>java.io.Serializable</code>, <code>java.lang.Cloneable</code>, <code>ptolemy.actor.Executable</code>, <code>ptolemy.actor.Initializable</code>, <code>ptolemy.actor.TimedDirector</code>, <code><a href="CTGeneralDirector.html" title="interface in ptolemy.domains.ct.kernel">CTGeneralDirector</a></code>, <code>ptolemy.kernel.util.Changeable</code>, <code>ptolemy.kernel.util.Debuggable</code>, <code>ptolemy.kernel.util.DebugListener</code>, <code>ptolemy.kernel.util.Derivable</code>, <code>ptolemy.kernel.util.ModelErrorHandler</code>, <code>ptolemy.kernel.util.MoMLExportable</code>, <code>ptolemy.kernel.util.Moveable</code>, <code>ptolemy.kernel.util.Nameable</code></dd>
</dl>
<dl class="notes">
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="CTEmbeddedDirector.html" title="class in ptolemy.domains.ct.kernel">CTEmbeddedDirector</a></code>, <code><a href="CTMixedSignalDirector.html" title="class in ptolemy.domains.ct.kernel">CTMixedSignalDirector</a></code></dd>
</dl>
<hr>
<pre>public class <span class="type-name-label">CTMultiSolverDirector</span>
extends <a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></pre>
<div class="block">A CTDirector that uses multiple ODE solvers. The reason for using different
 solvers is that we need to handle both normal integration of ODEs over a
 time interval and abrupt changes in signals (or actors' functions) that
 happen at discrete time points.
 <p>
 At the time points where abrupt changes happen, a special ODE solver, called
 <i>breakpointODESolver</i>, is used. Typically, breakpointODESolver does not
 advance time. The job for a breakpointODESolver is to find the states of
 the system at a breakpoint. Usually, the system has more than one state at
 such time points, which is also known as discontinuities. We call the first
 state at a discontinuity the <i>initial</i> state, and the last state the
 <i>final</i> state. Therefore, a breakpointODESolver is responsible to
 resolve the final state of a discontinuity from the inputs and the initial
 states.
 <p>
 The following paper gives a detailed explanation of initial and final states
 and how the initial and final states are resolved.
 <ul>
 <li>Edward A. Lee and Haiyang Zheng, <a href="http://ptolemy.eecs.berkeley.edu/publications/papers/05/OperationalSemantics">
 <i>Operational Semantics of Hybrid Systems</i>,
 Invited paper in Hybrid Systems: Computation and Control: 8th International
 Workshop, HSCC, LNCS 3414, Zurich, Switzerland, March 9-11, 2005</a></ul>
 <p>
 This director handles both predictable breakpoints, whose appearance can be
 assured before reaching the time points they happen, and unpredictable
 breakpoints, whose appearance is unknown before the simulation passes the
 time points they happen.
 <P>
 This director can only be a top-level director. For a CT model as
 an opaque composite actor inside another model, use
 CTMixedSignalDirector (if the outer model is a discrete-event
 model) or CTEmbeddedDirector (if the outer model is a CT model or a Modal
 model with a HSFSMDirector.)
 <P>
 This director recognizes actors that implement the CTStepSizeControlActor
 interface and adjusts the step size by polling such actors. If all actors
 are content with the current step size, then it attempts to raise the
 step size. If any actor is not satisfied with the current step size, then
 this director reduces the step size. A special case is that if there are
 no CT step size control actors, then this director uses 5 times of the
 current step size or the maximum step size, whichever is smaller.
 <P>
 This director has two more parameters than the CTDirector base class.<BR>
 <UL>
 <LI><I>ODESolver</I>: The name of the ODE solver that is used
 to integrate ODEs over a time interval.
 <LI><I>breakpointODESolver</I>: The name of the ODE solver used
 at breakpoints. The breakpoint ODE solvers do not need history information
 (this property is called self-start). Currently, there is only one such
 solver available,
 <a href="solver/DerivativeResolver.html" title="class in ptolemy.domains.ct.kernel.solver"><code>DerivativeResolver</code></a>.
 </UL></div>
<dl class="notes">
<dt>Since:</dt>
<dd>Ptolemy II 0.2</dd>
<dt>Version:</dt>
<dd>$Id: CTMultiSolverDirector.java 57040 2010-01-27 20:52:32Z cxh $</dd>
<dt>Author:</dt>
<dd>Jie Liu, Haiyang Zheng</dd>
<dt>See Also:</dt>
<dd><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel"><code>CTDirector</code></a>, 
<a href="../../../../serialized-form.html#ptolemy.domains.ct.kernel.CTMultiSolverDirector">Serialized Form</a></dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested.class.summary">
<h2>Nested Class Summary</h2>
<div class="inherited-list">
<h2 id="nested.classes.inherited.from.class.ptolemy.kernel.util.NamedObj">Nested classes/interfaces inherited from class&nbsp;ptolemy.kernel.util.NamedObj</h2>
<code>ptolemy.kernel.util.NamedObj.ContainedObjectsIterator</code></div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>private <a href="ODESolver.html" title="class in ptolemy.domains.ct.kernel">ODESolver</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_breakpointSolver">_breakpointSolver</a></span></code></th>
<td class="col-last">
<div class="block">The breakpoint solver.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>private java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_breakpointSolverClassName">_breakpointSolverClassName</a></span></code></th>
<td class="col-last">
<div class="block">The classname of the breakpoint ODE solver.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>protected boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_initialStatesNotReady">_initialStatesNotReady</a></span></code></th>
<td class="col-last">
<div class="block">Flag indicating the initial states are not ready.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>private <a href="ODESolver.html" title="class in ptolemy.domains.ct.kernel">ODESolver</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_normalSolver">_normalSolver</a></span></code></th>
<td class="col-last">
<div class="block">The normal solver.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>private java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_normalSolverClassName">_normalSolverClassName</a></span></code></th>
<td class="col-last">
<div class="block">The classname of the normal ODE solver.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>private static java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_solverClasspath">_solverClasspath</a></span></code></th>
<td class="col-last">
<div class="block">The classpath for solvers.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>ptolemy.data.expr.Parameter</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#breakpointODESolver">breakpointODESolver</a></span></code></th>
<td class="col-last">
<div class="block">The class name of the ODE solver that is used in the breakpoint
  iterations.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>ptolemy.data.expr.Parameter</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ODESolver">ODESolver</a></span></code></th>
<td class="col-last">
<div class="block">The class name of the normal ODE solver used in iterations for
  normal integration.</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="inherited-list">
<h3 id="fields.inherited.from.class.ptolemy.domains.ct.kernel.CTDirector">Fields inherited from class&nbsp;ptolemy.domains.ct.kernel.<a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></h3>
<code><a href="CTDirector.html#_timeBase">_timeBase</a>, <a href="CTDirector.html#errorTolerance">errorTolerance</a>, <a href="CTDirector.html#initStepSize">initStepSize</a>, <a href="CTDirector.html#maxIterations">maxIterations</a>, <a href="CTDirector.html#maxStepSize">maxStepSize</a>, <a href="CTDirector.html#minStepSize">minStepSize</a>, <a href="CTDirector.html#startTime">startTime</a>, <a href="CTDirector.html#stopTime">stopTime</a>, <a href="CTDirector.html#synchronizeToRealTime">synchronizeToRealTime</a>, <a href="CTDirector.html#valueResolution">valueResolution</a></code></div>
<div class="inherited-list">
<h3 id="fields.inherited.from.class.ptolemy.actor.sched.StaticSchedulingDirector">Fields inherited from class&nbsp;ptolemy.actor.sched.StaticSchedulingDirector</h3>
<code>_postfireReturns</code></div>
<div class="inherited-list">
<h3 id="fields.inherited.from.class.ptolemy.actor.Director">Fields inherited from class&nbsp;ptolemy.actor.Director</h3>
<code>_actorsFinishedExecution, _currentTime, _finishRequested, _initializables, _stopRequested, timeResolution</code></div>
<div class="inherited-list">
<h3 id="fields.inherited.from.class.ptolemy.kernel.util.NamedObj">Fields inherited from class&nbsp;ptolemy.kernel.util.NamedObj</h3>
<code>_changeListeners, _changeLock, _changeRequests, _debugging, _debugListeners, _elementName, _isPersistent, _verbose, _workspace, ATTRIBUTES, CLASSNAME, COMPLETE, CONTENTS, DEEP, FULLNAME, LINKS</code></div>
<div class="inherited-list">
<h3 id="fields.inherited.from.class.ptolemy.actor.Executable">Fields inherited from interface&nbsp;ptolemy.actor.Executable</h3>
<code>COMPLETED, NOT_READY, STOP_ITERATING</code></div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">CTMultiSolverDirector</a></span>()</code></th>
<td class="col-last">
<div class="block">Construct a director in the default workspace with an empty string
  as its name.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E(ptolemy.kernel.CompositeEntity,java.lang.String)">CTMultiSolverDirector</a></span>&#8203;(ptolemy.kernel.CompositeEntity&nbsp;container,
java.lang.String&nbsp;name)</code></th>
<td class="col-last">
<div class="block">Construct a director in the given container with the given name.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E(ptolemy.kernel.util.Workspace)">CTMultiSolverDirector</a></span>&#8203;(ptolemy.kernel.util.Workspace&nbsp;workspace)</code></th>
<td class="col-last">
<div class="block">Construct a director in the  workspace with an empty name.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>protected void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_continuousPhaseExecution()">_continuousPhaseExecution</a></span>()</code></th>
<td class="col-last">
<div class="block">This method performs a continuous phase of execution.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>protected void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_discretePhaseExecution()">_discretePhaseExecution</a></span>()</code></th>
<td class="col-last">
<div class="block">Perform a discrete phase of execution by processing all discrete events
  happening at the current model time.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>protected void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_initParameters()">_initParameters</a></span>()</code></th>
<td class="col-last">
<div class="block">Initialize parameters to their default values.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>protected boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_isOutputAccurate()">_isOutputAccurate</a></span>()</code></th>
<td class="col-last">
<div class="block">Return true if all step size control actors in the output
  schedule agree that the current step is accurate.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>protected boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_isStateAccurate()">_isStateAccurate</a></span>()</code></th>
<td class="col-last">
<div class="block">Return true if all step size control actors in the dynamic actor
  schedule and the state transition schedule agree that
  the current step size is accurate.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>protected void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_iterateEventGenerators(ptolemy.domains.ct.kernel.CTSchedule)">_iterateEventGenerators</a></span>&#8203;(<a href="CTSchedule.html" title="class in ptolemy.domains.ct.kernel">CTSchedule</a>&nbsp;schedule)</code></th>
<td class="col-last">
<div class="block">Iterate all event generators .</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>protected void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_iteratePurelyDiscreteActors(ptolemy.domains.ct.kernel.CTSchedule)">_iteratePurelyDiscreteActors</a></span>&#8203;(<a href="CTSchedule.html" title="class in ptolemy.domains.ct.kernel">CTSchedule</a>&nbsp;schedule)</code></th>
<td class="col-last">
<div class="block">Iterate all purely discrete-event actors.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>private void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_iterateSchedule(ptolemy.actor.sched.ScheduleElement)">_iterateSchedule</a></span>&#8203;(ptolemy.actor.sched.ScheduleElement&nbsp;schedule)</code></th>
<td class="col-last">
<div class="block">Iterate all the actors inside a given schedule, by prefiring,
  firing and postfiring them.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>protected void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_iterateWaveformGenerators(ptolemy.domains.ct.kernel.CTSchedule)">_iterateWaveformGenerators</a></span>&#8203;(<a href="CTSchedule.html" title="class in ptolemy.domains.ct.kernel">CTSchedule</a>&nbsp;schedule)</code></th>
<td class="col-last">
<div class="block">Iterate all wave generators.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>private void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_markStates()">_markStates</a></span>()</code></th>
<td class="col-last">
<div class="block">Mark the current state as the known good state.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>protected double</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_predictNextStepSize()">_predictNextStepSize</a></span>()</code></th>
<td class="col-last">
<div class="block">Predict the next step size.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>protected void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_propagateResolvedStates()">_propagateResolvedStates</a></span>()</code></th>
<td class="col-last">
<div class="block">Use breakpoint ODE solver to propagate the resolved states at the
  current phase of execution.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>private double</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_refinedStepWRTBreakpoints()">_refinedStepWRTBreakpoints</a></span>()</code></th>
<td class="col-last">
<div class="block">Adjust step size so that the first breakpoint is not in the middle
  of this step.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>protected double</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_refinedStepWRTOutput()">_refinedStepWRTOutput</a></span>()</code></th>
<td class="col-last">
<div class="block">Return the refined step size with respect to the output actors.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>protected double</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_refinedStepWRTState()">_refinedStepWRTState</a></span>()</code></th>
<td class="col-last">
<div class="block">Return the refined step size with respect to state accuracy
  requirement.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>protected boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_removeCurrentTimeFromBreakpointTable()">_removeCurrentTimeFromBreakpointTable</a></span>()</code></th>
<td class="col-last">
<div class="block">Return true if the current time is the first element in the breakpoint
  table, and remove that element from the breakpoint table.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>protected void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#_resolveInitialStates()">_resolveInitialStates</a></span>()</code></th>
<td class="col-last">
<div class="block">Resolve the initial states with a normal ODE solver at a further time.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#attributeChanged(ptolemy.kernel.util.Attribute)">attributeChanged</a></span>&#8203;(ptolemy.kernel.util.Attribute&nbsp;attribute)</code></th>
<td class="col-last">
<div class="block">React to a change in an attribute.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#canBeInsideDirector()">canBeInsideDirector</a></span>()</code></th>
<td class="col-last">
<div class="block">Return false always, since this director cannot be an inside director.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#canBeTopLevelDirector()">canBeTopLevelDirector</a></span>()</code></th>
<td class="col-last">
<div class="block">Return true since this director can be a top-level director.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#establishInitialStates()">establishInitialStates</a></span>()</code></th>
<td class="col-last">
<div class="block">Establish the initial states for discrete phase of execution.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#fire()">fire</a></span>()</code></th>
<td class="col-last">
<div class="block">Fire the system for one iteration.</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#fireEventGenerators()">fireEventGenerators</a></span>()</code></th>
<td class="col-last">
<div class="block">Fire event generators.</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code><a href="ODESolver.html" title="class in ptolemy.domains.ct.kernel">ODESolver</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getBreakpointSolver()">getBreakpointSolver</a></span>()</code></th>
<td class="col-last">
<div class="block">Return the breakpoint ODE solver.</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code><a href="CTGeneralDirector.html" title="interface in ptolemy.domains.ct.kernel">CTGeneralDirector</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getExecutiveCTGeneralDirector()">getExecutiveCTGeneralDirector</a></span>()</code></th>
<td class="col-last">
<div class="block">Always return null, because this director can not be an inside director.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code><a href="ODESolver.html" title="class in ptolemy.domains.ct.kernel">ODESolver</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getNormalODESolver()">getNormalODESolver</a></span>()</code></th>
<td class="col-last">
<div class="block">Return the ODE solver for normal integration.</div>
</td>
</tr>
<tr class="alt-color" id="i26">
<td class="col-first"><code>java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getODESolverClassName()">getODESolverClassName</a></span>()</code></th>
<td class="col-last">
<div class="block">Return the class name for the ODE solver.</div>
</td>
</tr>
<tr class="row-color" id="i27">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hasCurrentEvent()">hasCurrentEvent</a></span>()</code></th>
<td class="col-last">
<div class="block">Return true if there is an event at the current time.</div>
</td>
</tr>
<tr class="alt-color" id="i28">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#initialize()">initialize</a></span>()</code></th>
<td class="col-last">
<div class="block">Initialize the model for a simulation.</div>
</td>
</tr>
<tr class="row-color" id="i29">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#postfire()">postfire</a></span>()</code></th>
<td class="col-last">
<div class="block">Return true if this director wants to be fired again.</div>
</td>
</tr>
<tr class="alt-color" id="i30">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#postfireEventGenerators()">postfireEventGenerators</a></span>()</code></th>
<td class="col-last">
<div class="block">Postfire event generators.</div>
</td>
</tr>
<tr class="row-color" id="i31">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#prefire()">prefire</a></span>()</code></th>
<td class="col-last">
<div class="block">Call the prefire() method of the super class and return its value.</div>
</td>
</tr>
<tr class="alt-color" id="i32">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#preinitialize()">preinitialize</a></span>()</code></th>
<td class="col-last">
<div class="block">After calling the preinitialize() method of the super class,
  instantiate all the solvers.</div>
</td>
</tr>
<tr class="row-color" id="i33">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#produceOutput()">produceOutput</a></span>()</code></th>
<td class="col-last">
<div class="block">Fire all the actors in the output schedule.</div>
</td>
</tr>
<tr class="alt-color" id="i34">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#setInitialStatesNotReady()">setInitialStatesNotReady</a></span>()</code></th>
<td class="col-last">
<div class="block">Set the flag indicating that the initial states are not ready.</div>
</td>
</tr>
<tr class="row-color" id="i35">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#setModelTime(ptolemy.actor.util.Time)">setModelTime</a></span>&#8203;(ptolemy.actor.util.Time&nbsp;newTime)</code></th>
<td class="col-last">
<div class="block">Set a new value to the current time of the model, where the new
  time can be earlier than the current time to support rollback.</div>
</td>
</tr>
<tr class="alt-color" id="i36">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#updateContinuousStates()">updateContinuousStates</a></span>()</code></th>
<td class="col-last">
<div class="block">Call the postfire() method on all continuous actors in the schedule.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.ptolemy.domains.ct.kernel.CTDirector">Methods inherited from class&nbsp;ptolemy.domains.ct.kernel.<a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></h3>
<code><a href="CTDirector.html#_instantiateODESolver(java.lang.String)">_instantiateODESolver</a>, <a href="CTDirector.html#_setCurrentODESolver(ptolemy.domains.ct.kernel.ODESolver)">_setCurrentODESolver</a>, <a href="CTDirector.html#_setDiscretePhase(boolean)">_setDiscretePhase</a>, <a href="CTDirector.html#_setExecutionPhase(ptolemy.domains.ct.kernel.CTExecutionPhase)">_setExecutionPhase</a>, <a href="CTDirector.html#_setIterationBeginTime(ptolemy.actor.util.Time)">_setIterationBeginTime</a>, <a href="CTDirector.html#clone(ptolemy.kernel.util.Workspace)">clone</a>, <a href="CTDirector.html#delayDependency(double)">delayDependency</a>, <a href="CTDirector.html#fireAt(ptolemy.actor.Actor,ptolemy.actor.util.Time)">fireAt</a>, <a href="CTDirector.html#getBreakPoints()">getBreakPoints</a>, <a href="CTDirector.html#getCurrentODESolver()">getCurrentODESolver</a>, <a href="CTDirector.html#getCurrentStepSize()">getCurrentStepSize</a>, <a href="CTDirector.html#getErrorTolerance()">getErrorTolerance</a>, <a href="CTDirector.html#getExecutionPhase()">getExecutionPhase</a>, <a href="CTDirector.html#getInitialStepSize()">getInitialStepSize</a>, <a href="CTDirector.html#getIterationBeginTime()">getIterationBeginTime</a>, <a href="CTDirector.html#getMaxIterations()">getMaxIterations</a>, <a href="CTDirector.html#getMaxStepSize()">getMaxStepSize</a>, <a href="CTDirector.html#getMinStepSize()">getMinStepSize</a>, <a href="CTDirector.html#getModelNextIterationTime()">getModelNextIterationTime</a>, <a href="CTDirector.html#getModelStartTime()">getModelStartTime</a>, <a href="CTDirector.html#getModelStopTime()">getModelStopTime</a>, <a href="CTDirector.html#getSuggestedNextStepSize()">getSuggestedNextStepSize</a>, <a href="CTDirector.html#getValueResolution()">getValueResolution</a>, <a href="CTDirector.html#isDiscretePhase()">isDiscretePhase</a>, <a href="CTDirector.html#newReceiver()">newReceiver</a>, <a href="CTDirector.html#prefireClear()">prefireClear</a>, <a href="CTDirector.html#prefireDynamicActors()">prefireDynamicActors</a>, <a href="CTDirector.html#setCurrentStepSize(double)">setCurrentStepSize</a>, <a href="CTDirector.html#setSuggestedNextStepSize(double)">setSuggestedNextStepSize</a>, <a href="CTDirector.html#suggestedModalModelDirectors()">suggestedModalModelDirectors</a></code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.ptolemy.actor.sched.StaticSchedulingDirector">Methods inherited from class&nbsp;ptolemy.actor.sched.StaticSchedulingDirector</h3>
<code>_setScheduler, addDebugListener, getScheduler, invalidateSchedule, isScheduleValid, removeDebugListener, setScheduler</code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.ptolemy.actor.Director">Methods inherited from class&nbsp;ptolemy.actor.Director</h3>
<code>_description, _fireContainerAt, _isEmbedded, _isTopLevel, _transferInputs, _transferOutputs, addInitializable, createSchedule, defaultDependency, finish, fireAt, fireAtCurrentTime, getCausalityInterface, getCurrentTime, getGlobalTime, getModelTime, getNextIterationTime, getStartTime, getStopTime, getTimeResolution, implementsStrictActorSemantics, initialize, invalidateResolvedTypes, isFireFunctional, isStopRequested, isStrict, iterate, preinitialize, removeInitializable, requestInitialization, setContainer, setCurrentTime, stop, stopFire, supportMultirateFiring, terminate, transferInputs, transferOutputs, wrapup</code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.ptolemy.kernel.util.Attribute">Methods inherited from class&nbsp;ptolemy.kernel.util.Attribute</h3>
<code>_checkContainer, _getContainedObject, _propagateExistence, getContainer, moveDown, moveToFirst, moveToIndex, moveToLast, moveUp, setName, updateContent</code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.ptolemy.kernel.util.NamedObj">Methods inherited from class&nbsp;ptolemy.kernel.util.NamedObj</h3>
<code>_addAttribute, _adjustOverride, _attachText, _cloneFixAttributeFields, _debug, _debug, _debug, _debug, _debug, _exportMoMLContents, _getIndentPrefix, _isMoMLSuppressed, _markContentsDerived, _propagateValue, _recordDecoratedAttributes, _removeAttribute, _splitName, _stripNumericSuffix, _validateSettables, addChangeListener, attributeList, attributeList, attributeTypeChanged, clone, containedObjectsIterator, deepContains, depthInHierarchy, description, description, event, executeChangeRequests, exportMoML, exportMoML, exportMoML, exportMoML, exportMoML, exportMoMLPlain, getAttribute, getAttribute, getAttributes, getChangeListeners, getClassName, getDecoratorAttribute, getDecoratorAttributes, getDerivedLevel, getDerivedList, getDisplayName, getElementName, getFullName, getModelErrorHandler, getName, getName, getPrototypeList, getSource, handleModelError, isDeferringChangeRequests, isOverridden, isPersistent, lazyContainedObjectsIterator, message, propagateExistence, propagateValue, propagateValues, removeChangeListener, requestChange, setClassName, setDeferringChangeRequests, setDerivedLevel, setDisplayName, setModelErrorHandler, setPersistent, setSource, sortContainedObjects, toplevel, toString, uniqueName, validateSettables, workspace</code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.ptolemy.actor.TimedDirector">Methods inherited from interface&nbsp;ptolemy.actor.TimedDirector</h3>
<code>getModelTime, getTimeResolution</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="breakpointODESolver">
<h3>breakpointODESolver</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">ptolemy.data.expr.Parameter</span>&nbsp;<span class="member-name">breakpointODESolver</span></div>
<div class="block">The class name of the ODE solver that is used in the breakpoint
  iterations. The default value is a string:
  "ptolemy.domains.ct.kernel.solver.DerivativeResolver".</div>
</section>
</li>
<li>
<section class="detail" id="ODESolver">
<h3>ODESolver</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">ptolemy.data.expr.Parameter</span>&nbsp;<span class="member-name">ODESolver</span></div>
<div class="block">The class name of the normal ODE solver used in iterations for
  normal integration. The default value is a string:
  "ptolemy.domains.ct.kernel.solver.ExplicitRK23Solver".</div>
</section>
</li>
<li>
<section class="detail" id="_initialStatesNotReady">
<h3>_initialStatesNotReady</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">_initialStatesNotReady</span></div>
<div class="block">Flag indicating the initial states are not ready.
  FIXME: This isn't clear.... What is this flag for?
  Why is it so publically visible?</div>
</section>
</li>
<li>
<section class="detail" id="_breakpointSolver">
<h3>_breakpointSolver</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="ODESolver.html" title="class in ptolemy.domains.ct.kernel">ODESolver</a></span>&nbsp;<span class="member-name">_breakpointSolver</span></div>
<div class="block">The breakpoint solver.</div>
</section>
</li>
<li>
<section class="detail" id="_breakpointSolverClassName">
<h3>_breakpointSolverClassName</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">_breakpointSolverClassName</span></div>
<div class="block">The classname of the breakpoint ODE solver.</div>
</section>
</li>
<li>
<section class="detail" id="_normalSolver">
<h3>_normalSolver</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="ODESolver.html" title="class in ptolemy.domains.ct.kernel">ODESolver</a></span>&nbsp;<span class="member-name">_normalSolver</span></div>
<div class="block">The normal solver.</div>
</section>
</li>
<li>
<section class="detail" id="_normalSolverClassName">
<h3>_normalSolverClassName</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">_normalSolverClassName</span></div>
<div class="block">The classname of the normal ODE solver.</div>
</section>
</li>
<li>
<section class="detail" id="_solverClasspath">
<h3>_solverClasspath</h3>
<div class="member-signature"><span class="modifiers">private static</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">_solverClasspath</span></div>
<div class="block">The classpath for solvers.</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>CTMultiSolverDirector</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">CTMultiSolverDirector</span>()</div>
<div class="block">Construct a director in the default workspace with an empty string
  as its name. The director is added to the list of objects in
  the workspace. Increment the version number of the workspace.
  All the parameters take their default values.</div>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(ptolemy.kernel.CompositeEntity,java.lang.String)">
<h3>CTMultiSolverDirector</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">CTMultiSolverDirector</span>&#8203;(<span class="parameters">ptolemy.kernel.CompositeEntity&nbsp;container,
java.lang.String&nbsp;name)</span>
                      throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException,
ptolemy.kernel.util.NameDuplicationException</span></div>
<div class="block">Construct a director in the given container with the given name.
  The container argument must not be null, or a
  NullPointerException will be thrown.
  If the name argument is null, then the name is set to the
  empty string. Increment the version number of the workspace.
  All the parameters take their default values.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>container</code> - The container.</dd>
<dd><code>name</code> - Name of this director.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the director is not compatible
   with the specified container.  May be thrown in derived classes.</dd>
<dd><code>ptolemy.kernel.util.NameDuplicationException</code> - If the container is not a
   CompositeActor and the name collides with an entity in the container.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(ptolemy.kernel.util.Workspace)">
<h3>CTMultiSolverDirector</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">CTMultiSolverDirector</span>&#8203;(<span class="parameters">ptolemy.kernel.util.Workspace&nbsp;workspace)</span></div>
<div class="block">Construct a director in the  workspace with an empty name.
  The director is added to the list of objects in the workspace.
  Increment the version number of the workspace.
  All the parameters take their default values.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>workspace</code> - The workspace of this object.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="attributeChanged(ptolemy.kernel.util.Attribute)">
<h3>attributeChanged</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">attributeChanged</span>&#8203;(<span class="parameters">ptolemy.kernel.util.Attribute&nbsp;attribute)</span>
                      throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">React to a change in an attribute. If the changed attribute matches
  a parameter of the director, then the corresponding private copy of the
  parameter value will be updated.
  In particular, if the <i>ODESolver</i> parameter is changed, then
  the corresponding solver will be instantiated. If the new ODEsolver
  can not be instantiated, an IllegalActionException will be thrown, and
  the original ODESolver will be unchanged.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="CTDirector.html#attributeChanged(ptolemy.kernel.util.Attribute)">attributeChanged</a></code>&nbsp;in class&nbsp;<code><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></code></dd>
<dt>Parameters:</dt>
<dd><code>attribute</code> - The changed attribute.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the new solver can not be
  instantiated, or the change to other attributes is invalid.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="canBeInsideDirector()">
<h3>canBeInsideDirector</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">canBeInsideDirector</span>()</div>
<div class="block">Return false always, since this director cannot be an inside director.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="CTDirector.html#canBeInsideDirector()">canBeInsideDirector</a></code>&nbsp;in class&nbsp;<code><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></code></dd>
<dt>Returns:</dt>
<dd>false.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="canBeTopLevelDirector()">
<h3>canBeTopLevelDirector</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">canBeTopLevelDirector</span>()</div>
<div class="block">Return true since this director can be a top-level director.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="CTDirector.html#canBeTopLevelDirector()">canBeTopLevelDirector</a></code>&nbsp;in class&nbsp;<code><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></code></dd>
<dt>Returns:</dt>
<dd>true.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="establishInitialStates()">
<h3>establishInitialStates</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">establishInitialStates</span>()
                            throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Establish the initial states for discrete phase of execution. This
  method should be called if the initial states are not available. For
  example, the first iteration of the simulation, or the first execution
  of an enabled CT refinement.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If any actor can not be iterated, or
  can not ODE solver can not be set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="fire()">
<h3>fire</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">fire</span>()
          throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Fire the system for one iteration. One iteration is defined as
  solving the states of a system over a time interval [t_0, t_1].
  A complete iteration includes resolving final states at t_0,
  resolving the initial states at t_1, and producing outputs. This
  process includes a discrete phase of execution and a continuous phase
  of execution.
  <P>
  To resolve the final states at the time point t_0, a discrete
  phase of execution is performed. A discrete phase of execution
  at a time point is a fixed-point iteration, where the fixed
  point is reached when no more events exist and there will be
  no more events to be generated at that time point. To be
  concrete, at a discrete phase execution, event generators,
  purely discrete actors, waveform generators, and continuous
  actors are repeatedly iterated. The discrete phase of execution
  stops only when no event generators generate any more events. At the
  ending of the execution, the system states are resolved,
  which are called the final states at t_0. These states are marked as
  known good states for roll back purpose. The solver for the discrete
  phase of execution is a breakpoint ODE solver.
  <P>
  The way we find the fixed point is based on the synchronous reactive
  semantics. To be specific, the directors resolve the value of each
  signal from <i>unknown</i> to be either <i>absent</i> or
  <i>present</i>. This design is simple but firing all actors at each
  breakpoint causes overhead.
  <p>
  We could have used a smarter event queue like the one used by the DE
  director. Therefore only those actors with trigger events will be
  executed. However, this design will increase the complexity of this
  class. We assume that a CT model does not have many DE actors inside.
  If the discrete part of the model is complicated with a lot of DE
  actors, we would suggest using an opaque DE composite actor to
  encapsulate these DE actors and associate the composite actor with a
  DE director to take charge of the execution of those DE actors.
  <p>
  A continuous phase of execution immediately follows a discrete one,
  which solves the initial states at t_1. The initial states at t_1 are
  resolved by a normal ODE solver. This process is a normal integration
  over a time interval.
  <p>
  The ending time point t_1 of an iteration is determined by the step
  sizes suggested by the step size control actors and the earliest entry
  in the breakpoint table. A correct step size is no greater than the
  smallest suggested step size, and the current time plus the step size
  should not be later than the first entry in the breakpoint table.
  <p>
  Because of the existence of unpredictable events, a step size
  may need to be refined. Another reason to adjust step size is
  to achieve a reasonably accurate approximation of states. The
  mechanism to control step size is described below. After the
  states are resolved, step size control actors in the dynamic
  actor schedule and the state transition schedule are queried
  for the accuracy of the current step size. If any one of them
  is not satisfied with the current step size, then the states
  will be recalculated with a refined step size, which is the
  minimum of the refined step sizes from all step size control
  actors in the dynamic actor schedule and the state transition
  schedule. On the other hand, if all the above actors are
  satisfied with the current step, then the actors in the output
  path will be fired according to the output schedule. Then, the
  step size control actors in the output path will be checked
  for accuracy. If any actor is not satisfied with the current
  step size, the current step size is refined. Note that states
  have to be resolved again with this new step size. States are
  completely resolved only when all actors agree that the step size
  is accurate.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code>fire</code>&nbsp;in interface&nbsp;<code>ptolemy.actor.Executable</code></dd>
<dt>Specified by:</dt>
<dd><code><a href="CTDirector.html#fire()">fire</a></code>&nbsp;in class&nbsp;<code><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></code></dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If thrown in discrete or continuous
  phase of execution.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="fireEventGenerators()">
<h3>fireEventGenerators</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">fireEventGenerators</span>()
                         throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Fire event generators. This method is only called in a continuous
  phase of execution. Note that event generators are only fired but not
  postfired in this method.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the schedule does not exist,
  or any actor can not be prefired, or any actor throws it during firing.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getBreakpointSolver()">
<h3>getBreakpointSolver</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="ODESolver.html" title="class in ptolemy.domains.ct.kernel">ODESolver</a></span>&nbsp;<span class="member-name">getBreakpointSolver</span>()</div>
<div class="block">Return the breakpoint ODE solver.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The breakpoint ODE solver.</dd>
<dt>See Also:</dt>
<dd><a href="#getNormalODESolver()"><code>getNormalODESolver()</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getExecutiveCTGeneralDirector()">
<h3>getExecutiveCTGeneralDirector</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="CTGeneralDirector.html" title="interface in ptolemy.domains.ct.kernel">CTGeneralDirector</a></span>&nbsp;<span class="member-name">getExecutiveCTGeneralDirector</span>()</div>
<div class="block">Always return null, because this director can not be an inside director.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Null, always.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getNormalODESolver()">
<h3>getNormalODESolver</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="ODESolver.html" title="class in ptolemy.domains.ct.kernel">ODESolver</a></span>&nbsp;<span class="member-name">getNormalODESolver</span>()</div>
<div class="block">Return the ODE solver for normal integration.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The ODE solver for normal integration.</dd>
<dt>See Also:</dt>
<dd><a href="#getBreakpointSolver()"><code>getBreakpointSolver()</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getODESolverClassName()">
<h3>getODESolverClassName</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">getODESolverClassName</span>()</div>
<div class="block"><span class="descfrm-type-label">Description copied from interface:&nbsp;<code><a href="CTGeneralDirector.html#getODESolverClassName()">CTGeneralDirector</a></code></span></div>
<div class="block">Return the class name for the ODE solver.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The class name for the ODE solver.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasCurrentEvent()">
<h3>hasCurrentEvent</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">hasCurrentEvent</span>()</div>
<div class="block">Return true if there is an event at the current time. The event may be
  generated by event generators or if the current time was registered as a
  breakpoint.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>True if there is an event at current time.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="initialize()">
<h3>initialize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">initialize</span>()
                throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Initialize the model for a simulation. Construct a valid schedule.
  Invoke the initialize() method of the super class to set the current
  time and initialize all the actors directed by this director.
  Set the step size and the suggested next step size for the first firing.
  Register the stop time as a breakpoint.
  This method is called after data types are resolved.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code>initialize</code>&nbsp;in interface&nbsp;<code>ptolemy.actor.Initializable</code></dd>
<dt>Overrides:</dt>
<dd><code><a href="CTDirector.html#initialize()">initialize</a></code>&nbsp;in class&nbsp;<code><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></code></dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the initialize() method of the
  super class throws it, or the stop time can not be
  registered as a breakpoint.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="postfire()">
<h3>postfire</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">postfire</span>()
                 throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Return true if this director wants to be fired again. Return false, if
  the stop time is reached and no more actors need to be fired at that
  time, or if any actor returned false from its postfire() method.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code>postfire</code>&nbsp;in interface&nbsp;<code>ptolemy.actor.Executable</code></dd>
<dt>Overrides:</dt>
<dd><code><a href="CTDirector.html#postfire()">postfire</a></code>&nbsp;in class&nbsp;<code><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></code></dd>
<dt>Returns:</dt>
<dd>false If the simulation is finished.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If thrown by the super class, or the
  current model time is bigger than the stop time.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="prefire()">
<h3>prefire</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">prefire</span>()
                throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Call the prefire() method of the super class and return its value.
  Record the current model time as the beginning time of the current
  iteration.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code>prefire</code>&nbsp;in interface&nbsp;<code>ptolemy.actor.Executable</code></dd>
<dt>Overrides:</dt>
<dd><code>prefire</code>&nbsp;in class&nbsp;<code>ptolemy.actor.sched.StaticSchedulingDirector</code></dd>
<dt>Returns:</dt>
<dd>True if this director is ready to fire.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If thrown by the super class.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="preinitialize()">
<h3>preinitialize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">preinitialize</span>()
                   throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">After calling the preinitialize() method of the super class,
  instantiate all the solvers.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code>preinitialize</code>&nbsp;in interface&nbsp;<code>ptolemy.actor.Initializable</code></dd>
<dt>Overrides:</dt>
<dd><code><a href="CTDirector.html#preinitialize()">preinitialize</a></code>&nbsp;in class&nbsp;<code><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></code></dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If thrown by the super class,
  or not all solvers can be instantiated, or the current solver
  can not be set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="produceOutput()">
<h3>produceOutput</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">produceOutput</span>()
                   throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Fire all the actors in the output schedule.
  <p>
  If they have not be prefired, prefire them first. The abstract
  semantics require that prefire() be called exactly once in an iteration.
  This is important because, for example, time can only be tested
  reliably in prefire(). The time tested indicates the starting point of
  an integration step. During the following possibly multiple firings,
  time may progress, depending on the ODE solver used. Hierarchies in CT
  and hybrid systems cases actually rely on this fact to control internal
  step sizes.
  <p>
  FIXME: If we treat time as a state, it should not change until the
  postfire method!</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If there is no schedule, or any
  output actor can not be prefired or fired, or any output actor
  returns false from its prefire method.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="postfireEventGenerators()">
<h3>postfireEventGenerators</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">postfireEventGenerators</span>()
                             throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Postfire event generators. This method is only called in the
  continuous phase of execution, after the current step size is accepted
  by the output step size controllers. Note that discrete events must
  not be generated in this method. Instead, they will be
  generated in the immediately following discrete phase of execution.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the schedule does not exist, or
  any actor throws it during postfiring.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="setInitialStatesNotReady()">
<h3>setInitialStatesNotReady</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">setInitialStatesNotReady</span>()</div>
<div class="block">Set the flag indicating that the initial states are not ready.
  This method should only be used by the HSFSMDirector.</div>
</section>
</li>
<li>
<section class="detail" id="setModelTime(ptolemy.actor.util.Time)">
<h3>setModelTime</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">setModelTime</span>&#8203;(<span class="parameters">ptolemy.actor.util.Time&nbsp;newTime)</span></div>
<div class="block">Set a new value to the current time of the model, where the new
  time can be earlier than the current time to support rollback.
  This overrides the setCurrentTime() in the Director base class.
  This is a critical parameter in an execution, and the
  actors are not supposed to call it.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code>setModelTime</code>&nbsp;in class&nbsp;<code>ptolemy.actor.Director</code></dd>
<dt>Parameters:</dt>
<dd><code>newTime</code> - The new current simulation time.</dd>
<dt>See Also:</dt>
<dd><code>Director.getModelTime()</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="updateContinuousStates()">
<h3>updateContinuousStates</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">updateContinuousStates</span>()
                            throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Call the postfire() method on all continuous actors in the schedule.
  For a correct CT simulation, the state of a continuous actor can only
  change at this stage of an iteration.
  <p>
  If the <i>synchronizeToRealTime</i> parameter is <i>true</i>,
  then this method will block execution until the real time catches
  up with current model time. The units for time are seconds.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the synchronizeToRealTime
  parameter does not have a valid token, or the sleep is interrupted,
  or there is not a schedule, or any of the actors in the schedule can
  not be postfired.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_continuousPhaseExecution()">
<h3>_continuousPhaseExecution</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_continuousPhaseExecution</span>()
                                  throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">This method performs a continuous phase of execution. At this phase,
  a normal ODE solver tries to solve the initial states at a further time
  t_1, based on the inputs and final states at t_0, where t_0 < t_1.
  At the end of this method, outputs are generated.
  <p>
  Note that t_1 can be adjusted by the normal ODE solver with respect to
  the accuracy requirements from step size control actors. Therefore,
  this method starts with a guess of t_1, or an integration step size
  as (t_1 - t_0). If all step size control actors are satisfied with the
  guess, this method returns. Otherwise, the normal ODE solver chooses
  a smaller step size and tries to solve the states. Therefore, this
  method ends up with either resolved states or an exception complaining
  that states can not be resolved even with the preconfigured minimum
  step size.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If ODESolver can not be set or
  one of the continuous actors throws it.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_discretePhaseExecution()">
<h3>_discretePhaseExecution</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_discretePhaseExecution</span>()
                                throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Perform a discrete phase of execution by processing all discrete events
  happening at the current model time. In this method, event generators,
  purely discrete actors, waveform generators, and continuous actors are
  repeatedly iterated until the execution reaches a fixed point, where no
  more events exist at the current time.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If one of the actors throws it or
  the schedule does not exist.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_initParameters()">
<h3>_initParameters</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_initParameters</span>()</div>
<div class="block">Initialize parameters to their default values.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="CTDirector.html#_initParameters()">_initParameters</a></code>&nbsp;in class&nbsp;<code><a href="CTDirector.html" title="class in ptolemy.domains.ct.kernel">CTDirector</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_isOutputAccurate()">
<h3>_isOutputAccurate</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">_isOutputAccurate</span>()</div>
<div class="block">Return true if all step size control actors in the output
  schedule agree that the current step is accurate.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>True if all step size control actors agree with the current
  step size.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_isStateAccurate()">
<h3>_isStateAccurate</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">_isStateAccurate</span>()</div>
<div class="block">Return true if all step size control actors in the dynamic actor
  schedule and the state transition schedule agree that
  the current step size is accurate.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>True if all state step size control actors agree with the
  current step size.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_iteratePurelyDiscreteActors(ptolemy.domains.ct.kernel.CTSchedule)">
<h3>_iteratePurelyDiscreteActors</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_iteratePurelyDiscreteActors</span>&#8203;(<span class="parameters"><a href="CTSchedule.html" title="class in ptolemy.domains.ct.kernel">CTSchedule</a>&nbsp;schedule)</span>
                                     throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Iterate all purely discrete-event actors. Purely discrete-event actors
  are those take discrete signals as inputs and generate discrete
  signals as outputs.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>schedule</code> - The schedule that contains purely discrete-event actors.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If any actor can not be iterated.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_iterateEventGenerators(ptolemy.domains.ct.kernel.CTSchedule)">
<h3>_iterateEventGenerators</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_iterateEventGenerators</span>&#8203;(<span class="parameters"><a href="CTSchedule.html" title="class in ptolemy.domains.ct.kernel">CTSchedule</a>&nbsp;schedule)</span>
                                throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Iterate all event generators .</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>schedule</code> - The schedule that contains event generators.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If any actor can not be iterated.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_iterateWaveformGenerators(ptolemy.domains.ct.kernel.CTSchedule)">
<h3>_iterateWaveformGenerators</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_iterateWaveformGenerators</span>&#8203;(<span class="parameters"><a href="CTSchedule.html" title="class in ptolemy.domains.ct.kernel">CTSchedule</a>&nbsp;schedule)</span>
                                   throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Iterate all wave generators.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>schedule</code> - The schedule that contains wave generators.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If any actor can not be iterated.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_predictNextStepSize()">
<h3>_predictNextStepSize</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="member-name">_predictNextStepSize</span>()
                               throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Predict the next step size. If the current integration step is accurate,
  estimate the step size for the next iteration. The predicted step size
  is the minimum of predictions from all step size control actors,
  and it never exceeds 10 times of the current step size.
  If there are no step-size control actors at all, then return
  the current step size times 5. However, it never exceeds the maximum
  step size.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the prediced next step size.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the scheduler throws it.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_refinedStepWRTOutput()">
<h3>_refinedStepWRTOutput</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="member-name">_refinedStepWRTOutput</span>()
                                throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Return the refined step size with respect to the output actors.
  All the step size control actors in the output schedule are queried for
  a refined step size. The smallest one is returned.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The refined step size.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the scheduler throws it or the
  refined step size is less than the time resolution.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_refinedStepWRTState()">
<h3>_refinedStepWRTState</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="member-name">_refinedStepWRTState</span>()
                               throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Return the refined step size with respect to state accuracy
  requirement.
  All the step size control actors in the state transition
  and dynamic actor schedule are queried for a refined step size. Then
  the smallest one is returned.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The refined step size.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If the scheduler throws it, or the
  refined step size is less than the minimum step size parameter
  of the director.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_removeCurrentTimeFromBreakpointTable()">
<h3>_removeCurrentTimeFromBreakpointTable</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">_removeCurrentTimeFromBreakpointTable</span>()
                                                 throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Return true if the current time is the first element in the breakpoint
  table, and remove that element from the breakpoint table. Otherwise,
  the breakpoint table is unchanged.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true if the current time is a breakpoint.</dd>
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If a breakpoint is missed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_propagateResolvedStates()">
<h3>_propagateResolvedStates</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_propagateResolvedStates</span>()
                                 throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Use breakpoint ODE solver to propagate the resolved states at the
  current phase of execution.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If one of the actors throws it or
  the ODE solver can not be set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_resolveInitialStates()">
<h3>_resolveInitialStates</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_resolveInitialStates</span>()
                              throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Resolve the initial states with a normal ODE solver at a further time.
  The future time is the current time pulse the step size used by the
  solver. Return immediately if any actor returns false in their
  prefire() method. After this method is called, time advances to the
  future time.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If one the actors throws it
  in its execution methods.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_iterateSchedule(ptolemy.actor.sched.ScheduleElement)">
<h3>_iterateSchedule</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_iterateSchedule</span>&#8203;(<span class="parameters">ptolemy.actor.sched.ScheduleElement&nbsp;schedule)</span>
                       throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Iterate all the actors inside a given schedule, by prefiring,
  firing and postfiring them.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_markStates()">
<h3>_markStates</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">_markStates</span>()
                  throws <span class="exceptions">ptolemy.kernel.util.IllegalActionException</span></div>
<div class="block">Mark the current state as the known good state. Call the
  markStates() method on all CTStatefulActors.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>ptolemy.kernel.util.IllegalActionException</code> - If thrown by the scheduler.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_refinedStepWRTBreakpoints()">
<h3>_refinedStepWRTBreakpoints</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="member-name">_refinedStepWRTBreakpoints</span>()</div>
<div class="block">Adjust step size so that the first breakpoint is not in the middle
  of this step. Return the refined step size.</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
